# **Инструкция по работе с системой контроля версий Git**

## __Общая информация про Git__

__Git__ — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но также может использоваться для любых файлов). 

Изначально Git был создан *Линусом Торвальдсом* при разработке ядра Linux. 

![Linus](Linus.png)

Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью можно сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется __*контролем версий*__.

Необходимость контроля версий обусловлена следующими факторами:

1. возможность отслеживания изменений, произошедших с проектом, со временем
2. полезный функционал при одновременной работе нескольких специалистов над одним проектом

## __Начало работы с Git__

Для того, чтобы начать работу в Git, необходимо "представиться". Для этого в терминале вводятся следующие команды:
    
    git config --global user.name "My Name"
    git config --global user.email myEmail@example.com

Теперь каждое действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.
Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –global. Если этого не сделать, они будут распространяться только на текущий репозиторий.

Для того, чтобы посмотреть все настройки системы, используется команда:

    git config --list

Если система для работы в самом начале пути не настроена - ничего страшного. Git всегда подскажет разработчику, если тот запутался, например:

* Команда *git --help* - выводит общую документацию по git
* Если введем *git log --help* - он предоставит документацию по какой-то определенной команде (в данном случае это - log)
* Если вы вдруг сделали опечатку - система подскажет нужную команду
* После выполнения любой команды - отчитается о том, какие действия были совершены
* Также Git прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше

## __Инициализация репозитория__

На рабочем столе создается папка проекта. Далее, чтобы создать новый репозиторий, нужно открыть терминал, зайти в папку проекта и, чтобы инициализировать репозиторий, необходимо ввести команду:

    git init

Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки. 

Репозиторий был успешно создан, но пока что пуст. Теперь необходимо создать текстовый файл с конкретным именем и указать его расширение к примеру *hello.txt*.

## __Проверка состояния репозитория__

Status — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск git status на свежесозданном репозитории должен выдать:

    git status
    On branch master
    Initial commit
    Untracked files:
    (use "git add ..." to include in what will be committed) hello.txt

Сообщение говорит о том, что файл hello.txt неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

## __Добавление версионности__

В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой commit.
В нашем случае у нас только один файл, так что добавим его:

    git add hello.txt

Если нам нужно добавить все, что находится в директории, мы можем использовать

    git add -A

Проверим статус снова, на этот раз мы должны получить другой ответ:

    git status
    On branch master
    Initial commit
    Changes to be committed: (use "git rm --cached ..." to unstage) new file: hello.txt

Файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.

## __Фиксация изменений__

Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды git add, добавляющей (или подготавливающей) их к коммиту:

    git add .\hello.txt

Теперь создадим непосредственно сам коммит

    git commit -m 'Add some code'

Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

## __Просмотр истории коммитов__

Для просмотра всех выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:

    git log

В ней содержиться вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие операции в списке изменений, можно по хэшу коммита, при помощи команды git show :

    git show hash_commit

Ну а если вдруг нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:

    git commit --amend -m 'Новый комментарий'

В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.

## __Переключение между версиями__

Каждый коммит имеет уникальный идентифицирующий хеш SHA-1. Эти идентификаторы используются для перемещения по временной шкале коммитов и возвращения к коммитам.

Один из лучших инструментов для просмотра истории репозитория Git — команда __*git log*__.

По умолчанию git log показывает только коммиты текущей выбранной ветки. После того как вы нашли ссылку на нужный коммит в истории, для перехода к нему можно использовать команду __*git checkout*__. Команда git checkout — это простой способ «загрузить» любой из этих сохраненных снимков на компьютер разработчика. При стандартном процессе разработки указатель HEAD обычно указывает на главную ветку main или другую локальную ветку. Но при переключении на предыдущий коммит HEAD указывает уже не на ветку, а непосредственно на сам коммит.

Переход к старой версии файла не перемещает указатель HEAD. Он остается в той же ветке и в том же коммите, что позволяет избежать открепления указателя HEAD. После этого можно выполнить коммит старой версии файла в новый снимок состояния, как и в случае других изменений. Соответственно, такое использование команды git checkout применительно к файлу позволяет откатиться к прежней версии отдельного файла. 

## __Добавление в текст графических изображений__

Для того, чтобы добавить в текст графическое изображение, необходимо ввести команду: 

    ![Текст с описанием картинки](/images/picture.jpg)

где /images/picture.jpg - имя файла в папке расположения.

Поскольку графическое изображение относится к бинарным файлам, Git его отслеживает с трудом, поэтому целесообразно графические изображения вносить в файл __*.gitignore*__ - служебный файл для игнорируемых файлов.
Изменения в данном файле сохраняются через команду 

    git add .\.gitignore

## __Ветвление в Git__

Ветвление в Гит позволяет нам работать параллельно с разными задачами в одном репозитори.

Для того, чтобы посмотреть список веток в репозитории, необходимо ввести команду

    git branch

## __Создание новой ветки__

Для создания новой ветки используется команда 

    git branch <имя_ветки>

 ## __Слияние веток__

 Мастер - это основная ветка проекта, в которую заливается только рабочий проверенный код. Новый функционал в конце концов оказывается в мастере.
 
 Чтобы влить одну ветку в другую, нужно, находясь на той ветке, __*куда*__ вливаем, выполнить команду:

    git merge <имя_вливаемой_ветки>

### __*Конфликты при слиянии веток*__

![Conflicts](git-merge-without-conflict.jpg)

Зачастую при слиянии веток возникают конфликты, вызванные тем, что в текущей ветке (master) и в той, которую мы пытаемся вмерджить есть изменения в одних и тех же участках кода. 

Для того. чтобы разрешить (разрезолвить) конфликт, необходимо проанализировать противоречия в сливаемых ветках, приветси их к общему знаменателю и сообщить Git, что конфликт разрешен. Для этого просто нужно закоммитить изменения.

## __Изменения в ветках__

Для того, чтобы увидеть различия между последней сохраненной и текущей версиями ветки, используется команда

    git diff

Для того, чтобы сравнить конкретные версии, в данной команде указываются хеши версий. К примеру,

    git diff d67jj98 jk984kd

Все произведенные действия в текущей версии ветки можно вывести в упрощенном виде по команде

    git log --oneline

а по всему репозиторию по команде

    git log --oneline --all

Для отображения изменений в последовательности по разным веткам используется команда

    git log --graph

## __Удаление веток__

Для того, чтобы удалить ветку, необходимо, находясь в ветке "мастер", ввести команду:

    git branch -d <название ветки>

Для удаления используется флажок -d, поскольку именно этот флажок позволяет удалить ветку. полностью "влитую" в иную ветку, и это удаление не поломает иные ветки.

Использование в данной команде флажка __*-D*__ приведет к удалению ветки с несохраненными данными, то есть к "принудительному" удалению.

